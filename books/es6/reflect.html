<!DOCTYPE HTML>
<html lang="">
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>14. Reflect</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="description" content="">
    <meta name="generator" content="GitBook 3.2.3">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/style.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-page-toc-button/plugin.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-highlight/website.css">
    <!--
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search.css">
    -->
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/search.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-fontsettings/website.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-splitter/splitter.css">
    <link href="page_styles.css" rel="stylesheet" type="text/css"><link href="stylesheet.css" rel="stylesheet" type="text/css">
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152"
          href="https://cdn.jim.plus/gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://cdn.jim.plus/gitbook/images/favicon.ico" type="image/x-icon">
    <link rel="next" href="promise.html"/>
    <link rel="prev" href="proxy.html"/>
</head>
<body>
<div class="book">
    <div class="book-summary">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search"/>
        </div>
    <nav role="navigation">
    <ul class="summary">
<li class="chapter" data-level="1" data-path="titlepage.html">
    <a href="titlepage.html">Cover</a>
</li>
<li class="chapter" data-level="2" data-path="SUMMARY.html">
    <a href="SUMMARY.html">Table of Contents</a>
</li>
<li class="chapter" data-level="3" data-path="index.html">
    <a href="index.html">0. 前言</a>
</li>
<li class="chapter" data-level="4" data-path="intro.html">
    <a href="intro.html">1. ECMAScript 6简介</a>
</li>
<li class="chapter" data-level="5" data-path="let.html">
    <a href="let.html">2. let 和 const 命令</a>
</li>
<li class="chapter" data-level="6" data-path="destructuring.html">
    <a href="destructuring.html">3. 变量的解构赋值</a>
</li>
<li class="chapter" data-level="7" data-path="string.html">
    <a href="string.html">4. 字符串的扩展</a>
</li>
<li class="chapter" data-level="8" data-path="regex.html">
    <a href="regex.html">5. 正则的扩展</a>
</li>
<li class="chapter" data-level="9" data-path="number.html">
    <a href="number.html">6. 数值的扩展</a>
</li>
<li class="chapter" data-level="10" data-path="function.html">
    <a href="function.html">7. 函数的扩展</a>
</li>
<li class="chapter" data-level="11" data-path="fp.html">
    <a href="fp.html">8. 函数式编程</a>
</li>
<li class="chapter" data-level="12" data-path="array.html">
    <a href="array.html">9. 数组的扩展</a>
</li>
<li class="chapter" data-level="13" data-path="object.html">
    <a href="object.html">10. 对象的扩展</a>
</li>
<li class="chapter" data-level="14" data-path="symbol.html">
    <a href="symbol.html">11. Symbol</a>
</li>
<li class="chapter" data-level="15" data-path="set-map.html">
    <a href="set-map.html">12. Set 和 Map 数据结构</a>
</li>
<li class="chapter" data-level="16" data-path="proxy.html">
    <a href="proxy.html">13. Proxy</a>
</li>
<li class="chapter" data-level="17" data-path="reflect.html">
    <a href="reflect.html">14. Reflect</a>
</li>
<li class="chapter" data-level="18" data-path="promise.html">
    <a href="promise.html">15. Promise 对象</a>
</li>
<li class="chapter" data-level="19" data-path="iterator.html">
    <a href="iterator.html">16. Iterator 和 for...of 循环</a>
</li>
<li class="chapter" data-level="20" data-path="generator.html">
    <a href="generator.html">17. Generator 函数的语法</a>
</li>
<li class="chapter" data-level="21" data-path="generator-async.html">
    <a href="generator-async.html">18. Generator 函数的异步应用</a>
</li>
<li class="chapter" data-level="22" data-path="async.html">
    <a href="async.html">19. async 函数</a>
</li>
<li class="chapter" data-level="23" data-path="class.html">
    <a href="class.html">20. Class 的基本语法</a>
</li>
<li class="chapter" data-level="24" data-path="class-extends.html">
    <a href="class-extends.html">21. Class 的继承</a>
</li>
<li class="chapter" data-level="25" data-path="mixin.html">
    <a href="mixin.html">22. Mixin</a>
</li>
<li class="chapter" data-level="26" data-path="simd.html">
    <a href="simd.html">23. SIMD</a>
</li>
<li class="chapter" data-level="27" data-path="decorator.html">
    <a href="decorator.html">24. Decorator</a>
</li>
<li class="chapter" data-level="28" data-path="module.html">
    <a href="module.html">25. Module 的语法</a>
</li>
<li class="chapter" data-level="29" data-path="module-loader.html">
    <a href="module-loader.html">26. Module 的加载实现</a>
</li>
<li class="chapter" data-level="30" data-path="style.html">
    <a href="style.html">27. 编程风格</a>
</li>
<li class="chapter" data-level="31" data-path="spec.html">
    <a href="spec.html">28. 读懂规格</a>
</li>
<li class="chapter" data-level="32" data-path="arraybuffer.html">
    <a href="arraybuffer.html">29. ArrayBuffer</a>
</li>
<li class="chapter" data-level="33" data-path="proposals.html">
    <a href="proposals.html">30. 最新提案</a>
</li>
<li class="chapter" data-level="34" data-path="reference.html">
    <a href="reference.html">31. 参考链接</a>
</li>
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                Published with GitBook
            </a>
        </li>
    </ul>
</nav>
    </div>
    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
                <!-- Title -->
                <h1>
                    <i class="fa fa-circle-o-notch fa-spin"></i>
                    <a href="reflect.html">14. Reflect</a>
                </h1>
            </div>
            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                    <div id="book-search-results">
                        <div class="search-noresults">
                            <section class="normal markdown-section">
                            <div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_15">14. Reflect</h1>
        <div class="section">
            <h1 id="reflect" class="calibre5">Reflect</h1>
<h2 id="概述" class="calibre16">概述</h2>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象与<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象的设计目的有这样几个。</p>
<p class="calibre6">（1） 将<code class="pcalibre3 calibre13 pcalibre4">Object</code>对象的一些明显属于语言内部的方法（比如<code class="pcalibre3 calibre13 pcalibre4">Object.defineProperty</code>），放到<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象上。现阶段，某些方法同时在<code class="pcalibre3 calibre13 pcalibre4">Object</code>和<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象上部署，未来的新方法将只部署在<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象上。也就是说，从<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象上可以拿到语言内部的方法。</p>
<p class="calibre6">（2） 修改某些<code class="pcalibre3 calibre13 pcalibre4">Object</code>方法的返回结果，让其变得更合理。比如，<code class="pcalibre3 calibre13 pcalibre4">Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty(obj, name, desc)</code>则会返回<code class="pcalibre3 calibre13 pcalibre4">false</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-number">Object</span>.defineProperty(target, property, attributes);
  <span class="hljs-comment">// success</span>
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// failure</span>
}

<span class="hljs-comment">// 新写法</span>
<span class="hljs-keyword">if</span> (<span class="hljs-number">Reflect</span>.defineProperty(target, property, attributes)) {
  <span class="hljs-comment">// success</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// failure</span>
}
</code></pre>
<p class="calibre6">（3） 让<code class="pcalibre3 calibre13 pcalibre4">Object</code>操作都变成函数行为。某些<code class="pcalibre3 calibre13 pcalibre4">Object</code>操作是命令式，比如<code class="pcalibre3 calibre13 pcalibre4">name in obj</code>和<code class="pcalibre3 calibre13 pcalibre4">delete obj[name]</code>，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.has(obj, name)</code>和<code class="pcalibre3 calibre13 pcalibre4">Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-string">&#39;assign&#39;</span> <span class="hljs-keyword">in</span> <span class="hljs-number">Object</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.has(<span class="hljs-number">Object</span>, <span class="hljs-string">&#39;assign&#39;</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">（4）<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象的方法与<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象的方法一一对应，只要是<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象的方法，就能在<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象上找到对应的方法。这就让<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象可以方便地调用对应的<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>怎么修改默认行为，你总可以在<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>上获取默认行为。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Proxy</span>(target, {
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-number">target, name, value, receiver</span>) </span>{
    <span class="hljs-keyword">var</span> success = <span class="hljs-number">Reflect</span>.set(target,name, value, receiver);
    <span class="hljs-keyword">if</span> (success) {
      log(<span class="hljs-string">&#39;property &#39;</span> + name + <span class="hljs-string">&#39; on &#39;</span> + target + <span class="hljs-string">&#39; set to &#39;</span> + value);
    }
    <span class="hljs-keyword">return</span> success;
  }
});
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>方法拦截<code class="pcalibre3 calibre13 pcalibre4">target</code>对象的属性赋值行为。它采用<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
<p class="calibre6">下面是另一个例子。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> loggedObj = <span class="hljs-keyword">new</span> <span class="hljs-number">Proxy</span>(obj, {
  get(target, name) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;get&#39;</span>, target, name);
    <span class="hljs-keyword">return</span> <span class="hljs-number">Reflect</span>.get(target, name);
  },
  deleteProperty(target, name) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;delete&#39;</span> + name);
    <span class="hljs-keyword">return</span> <span class="hljs-number">Reflect</span>.deleteProperty(target, name);
  },
  has(target, name) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;has&#39;</span> + name);
    <span class="hljs-keyword">return</span> <span class="hljs-number">Reflect</span>.has(target, name);
  }
});
</code></pre>
<p class="calibre6">上面代码中，每一个<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象的拦截操作（<code class="pcalibre3 calibre13 pcalibre4">get</code>、<code class="pcalibre3 calibre13 pcalibre4">delete</code>、<code class="pcalibre3 calibre13 pcalibre4">has</code>），内部都调用对应的<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p class="calibre6">有了<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象以后，很多操作会更易读。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-number">Function</span>.prototype.apply.call(<span class="hljs-number">Math</span>.floor, <span class="hljs-number">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.apply(<span class="hljs-number">Math</span>.floor, <span class="hljs-number">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span>
</code></pre>
<h2 id="静态方法" class="calibre12">静态方法</h2>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象一共有 13 个静态方法。</p>
<ul class="calibre9">
<li class="calibre10">Reflect.apply(target, thisArg, args)</li>
<li class="calibre10">Reflect.construct(target, args)</li>
<li class="calibre10">Reflect.get(target, name, receiver)</li>
<li class="calibre10">Reflect.set(target, name, value, receiver)</li>
<li class="calibre10">Reflect.defineProperty(target, name, desc)</li>
<li class="calibre10">Reflect.deleteProperty(target, name)</li>
<li class="calibre10">Reflect.has(target, name)</li>
<li class="calibre10">Reflect.ownKeys(target)</li>
<li class="calibre10">Reflect.isExtensible(target)</li>
<li class="calibre10">Reflect.preventExtensions(target)</li>
<li class="calibre10">Reflect.getOwnPropertyDescriptor(target, name)</li>
<li class="calibre10">Reflect.getPrototypeOf(target)</li>
<li class="calibre10">Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p class="calibre6">上面这些方法的作用，大部分与<code class="pcalibre3 calibre13 pcalibre4">Object</code>对象的同名方法的作用都是相同的，而且它与<code class="pcalibre3 calibre13 pcalibre4">Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>
<h3 id="reflectgettarget-name-receiver" class="calibre11">Reflect.get(target, name, receiver)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.get</code>方法查找并返回<code class="pcalibre3 calibre13 pcalibre4">target</code>对象的<code class="pcalibre3 calibre13 pcalibre4">name</code>属性，如果没有该属性，则返回<code class="pcalibre3 calibre13 pcalibre4">undefined</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>,
  get baz() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo + <span class="hljs-keyword">this</span>.bar;
  },
}

<span class="hljs-number">Reflect</span>.get(myObject, <span class="hljs-string">&#39;foo&#39;</span>) <span class="hljs-comment">// 1</span>
<span class="hljs-number">Reflect</span>.get(myObject, <span class="hljs-string">&#39;bar&#39;</span>) <span class="hljs-comment">// 2</span>
<span class="hljs-number">Reflect</span>.get(myObject, <span class="hljs-string">&#39;baz&#39;</span>) <span class="hljs-comment">// 3</span>
</code></pre>
<p class="calibre6">如果<code class="pcalibre3 calibre13 pcalibre4">name</code>属性部署了读取函数（getter），则读取函数的<code class="pcalibre3 calibre13 pcalibre4">this</code>绑定<code class="pcalibre3 calibre13 pcalibre4">receiver</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>,
  get baz() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo + <span class="hljs-keyword">this</span>.bar;
  },
};

<span class="hljs-keyword">var</span> myReceiverObject = {
  foo: <span class="hljs-number">4</span>,
  bar: <span class="hljs-number">4</span>,
};

<span class="hljs-number">Reflect</span>.get(myObject, <span class="hljs-string">&#39;baz&#39;</span>, myReceiverObject) <span class="hljs-comment">// 8</span>
</code></pre>
<p class="calibre6">如果第一个参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Reflect.get</code>方法会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">&#39;foo&#39;</span>) <span class="hljs-comment">// 报错</span>
<span class="hljs-number">Reflect</span>.get(<span class="hljs-number">false</span>, <span class="hljs-string">&#39;foo&#39;</span>) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="reflectsettarget-name-value-receiver" class="calibre11">Reflect.set(target, name, value, receiver)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>方法设置<code class="pcalibre3 calibre13 pcalibre4">target</code>对象的<code class="pcalibre3 calibre13 pcalibre4">name</code>属性等于<code class="pcalibre3 calibre13 pcalibre4">value</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  set bar(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo = value;
  },
}

myObject.foo <span class="hljs-comment">// 1</span>

<span class="hljs-number">Reflect</span>.set(myObject, <span class="hljs-string">&#39;foo&#39;</span>, <span class="hljs-number">2</span>);
myObject.foo <span class="hljs-comment">// 2</span>

<span class="hljs-number">Reflect</span>.set(myObject, <span class="hljs-string">&#39;bar&#39;</span>, <span class="hljs-number">3</span>)
myObject.foo <span class="hljs-comment">// 3</span>
</code></pre>
<p class="calibre6">如果<code class="pcalibre3 calibre13 pcalibre4">name</code>属性设置了赋值函数，则赋值函数的<code class="pcalibre3 calibre13 pcalibre4">this</code>绑定<code class="pcalibre3 calibre13 pcalibre4">receiver</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">4</span>,
  set bar(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo = value;
  },
};

<span class="hljs-keyword">var</span> myReceiverObject = {
  foo: <span class="hljs-number">0</span>,
};

<span class="hljs-number">Reflect</span>.set(myObject, <span class="hljs-string">&#39;bar&#39;</span>, <span class="hljs-number">1</span>, myReceiverObject);
myObject.foo <span class="hljs-comment">// 4</span>
myReceiverObject.foo <span class="hljs-comment">// 1</span>
</code></pre>
<p class="calibre6">注意，如果 Proxy 对象和 Reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code class="pcalibre3 calibre13 pcalibre4">receiver</code>，那么<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>会触发<code class="pcalibre3 calibre13 pcalibre4">Proxy.defineProperty</code>拦截。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> p = {
  a: <span class="hljs-string">&#39;a&#39;</span>
};

<span class="hljs-keyword">let</span> handler = {
  set(target, key, value, receiver) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;set&#39;</span>);
    <span class="hljs-number">Reflect</span>.set(target, key, value, receiver)
  },
  defineProperty(target, key, attribute) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;defineProperty&#39;</span>);
    <span class="hljs-number">Reflect</span>.defineProperty(target, key, attribute);
  }
};

<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-number">Proxy</span>(p, handler);
obj.a = <span class="hljs-string">&#39;A&#39;</span>;
<span class="hljs-comment">// set</span>
<span class="hljs-comment">// defineProperty</span>
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">Proxy.set</code>拦截里面使用了<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>，而且传入了<code class="pcalibre3 calibre13 pcalibre4">receiver</code>，导致触发<code class="pcalibre3 calibre13 pcalibre4">Proxy.defineProperty</code>拦截。这是因为<code class="pcalibre3 calibre13 pcalibre4">Proxy.set</code>的<code class="pcalibre3 calibre13 pcalibre4">receiver</code>参数总是指向当前的 Proxy 实例（即上例的<code class="pcalibre3 calibre13 pcalibre4">obj</code>），而<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>一旦传入<code class="pcalibre3 calibre13 pcalibre4">receiver</code>，就会将属性赋值到<code class="pcalibre3 calibre13 pcalibre4">receiver</code>上面（即<code class="pcalibre3 calibre13 pcalibre4">obj</code>），导致触发<code class="pcalibre3 calibre13 pcalibre4">defineProperty</code>拦截。如果<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>没有传入<code class="pcalibre3 calibre13 pcalibre4">receiver</code>，那么就不会触发<code class="pcalibre3 calibre13 pcalibre4">defineProperty</code>拦截。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> p = {
  a: <span class="hljs-string">&#39;a&#39;</span>
};

<span class="hljs-keyword">let</span> handler = {
  set(target, key, value, receiver) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;set&#39;</span>);
    <span class="hljs-number">Reflect</span>.set(target, key, value)
  },
  defineProperty(target, key, attribute) {
    <span class="hljs-number">console</span>.log(<span class="hljs-string">&#39;defineProperty&#39;</span>);
    <span class="hljs-number">Reflect</span>.defineProperty(target, key, attribute);
  }
};

<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-number">Proxy</span>(p, handler);
obj.a = <span class="hljs-string">&#39;A&#39;</span>;
<span class="hljs-comment">// set</span>
</code></pre>
<p class="calibre6">如果第一个参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Reflect.set</code>会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Reflect</span>.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#39;foo&#39;</span>, {}) <span class="hljs-comment">// 报错</span>
<span class="hljs-number">Reflect</span>.set(<span class="hljs-number">false</span>, <span class="hljs-string">&#39;foo&#39;</span>, {}) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="reflecthasobj-name" class="calibre11">Reflect.has(obj, name)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.has</code>方法对应<code class="pcalibre3 calibre13 pcalibre4">name in obj</code>里面的<code class="pcalibre3 calibre13 pcalibre4">in</code>运算符。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
};

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-string">&#39;foo&#39;</span> <span class="hljs-keyword">in</span> myObject <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.has(myObject, <span class="hljs-string">&#39;foo&#39;</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">如果第一个参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Reflect.has</code>和<code class="pcalibre3 calibre13 pcalibre4">in</code>运算符都会报错。</p>
<h3 id="reflectdeletepropertyobj-name" class="calibre11">Reflect.deleteProperty(obj, name)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.deleteProperty</code>方法等同于<code class="pcalibre3 calibre13 pcalibre4">delete obj[name]</code>，用于删除对象的属性。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> myObj = { foo: <span class="hljs-string">&#39;bar&#39;</span> };

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-keyword">delete</span> myObj.foo;

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.deleteProperty(myObj, <span class="hljs-string">&#39;foo&#39;</span>);
</code></pre>
<p class="calibre6">该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code class="pcalibre3 calibre13 pcalibre4">true</code>；删除失败，被删除的属性依然存在，返回<code class="pcalibre3 calibre13 pcalibre4">false</code>。</p>
<h3 id="reflectconstructtarget-args" class="calibre11">Reflect.construct(target, args)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.construct</code>方法等同于<code class="pcalibre3 calibre13 pcalibre4">new target(...args)</code>，这提供了一种不使用<code class="pcalibre3 calibre13 pcalibre4">new</code>，来调用构造函数的方法。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">Greeting</span>(<span class="hljs-number">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
}

<span class="hljs-comment">// new 的写法</span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Greeting(<span class="hljs-string">&#39;张三&#39;</span>);

<span class="hljs-comment">// Reflect.construct 的写法</span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-number">Reflect</span>.construct(Greeting, [<span class="hljs-string">&#39;张三&#39;</span>]);
</code></pre>
<h3 id="reflectgetprototypeofobj" class="calibre11">Reflect.getPrototypeOf(obj)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.getPrototypeOf</code>方法用于读取对象的<code class="pcalibre3 calibre13 pcalibre4">__proto__</code>属性，对应<code class="pcalibre3 calibre13 pcalibre4">Object.getPrototypeOf(obj)</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> myObj = <span class="hljs-keyword">new</span> FancyThing();

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.getPrototypeOf</code>和<code class="pcalibre3 calibre13 pcalibre4">Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.getPrototypeOf</code>会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Object</span>.getPrototypeOf(<span class="hljs-number">1</span>) <span class="hljs-comment">// Number {[[PrimitiveValue]]: 0}</span>
<span class="hljs-number">Reflect</span>.getPrototypeOf(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="reflectsetprototypeofobj-newproto" class="calibre11">Reflect.setPrototypeOf(obj, newProto)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.setPrototypeOf</code>方法用于设置对象的<code class="pcalibre3 calibre13 pcalibre4">__proto__</code>属性，返回第一个参数对象，对应<code class="pcalibre3 calibre13 pcalibre4">Object.setPrototypeOf(obj, newProto)</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> myObj = <span class="hljs-keyword">new</span> FancyThing();

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.setPrototypeOf(myObj, OtherThing.prototype);

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.setPrototypeOf(myObj, OtherThing.prototype);
</code></pre>
<p class="calibre6">如果第一个参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Object.setPrototypeOf</code>会返回第一个参数本身，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.setPrototypeOf</code>会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Object</span>.setPrototypeOf(<span class="hljs-number">1</span>, {})
<span class="hljs-comment">// 1</span>

<span class="hljs-number">Reflect</span>.setPrototypeOf(<span class="hljs-number">1</span>, {})
<span class="hljs-comment">// TypeError: Reflect.setPrototypeOf called on non-object</span>
</code></pre>
<p class="calibre6">如果第一个参数是<code class="pcalibre3 calibre13 pcalibre4">undefined</code>或<code class="pcalibre3 calibre13 pcalibre4">null</code>，<code class="pcalibre3 calibre13 pcalibre4">Object.setPrototypeOf</code>和<code class="pcalibre3 calibre13 pcalibre4">Reflect.setPrototypeOf</code>都会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Object</span>.setPrototypeOf(<span class="hljs-number">null</span>, {})
<span class="hljs-comment">// TypeError: Object.setPrototypeOf called on null or undefined</span>

<span class="hljs-number">Reflect</span>.setPrototypeOf(<span class="hljs-number">null</span>, {})
<span class="hljs-comment">// TypeError: Reflect.setPrototypeOf called on non-object</span>
</code></pre>
<h3 id="reflectapplyfunc-thisarg-args" class="calibre11">Reflect.apply(func, thisArg, args)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.apply</code>方法等同于<code class="pcalibre3 calibre13 pcalibre4">Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code class="pcalibre3 calibre13 pcalibre4">this</code>对象后执行给定函数。</p>
<p class="calibre6">一般来说，如果要绑定一个函数的<code class="pcalibre3 calibre13 pcalibre4">this</code>对象，可以这样写<code class="pcalibre3 calibre13 pcalibre4">fn.apply(obj, args)</code>，但是如果函数定义了自己的<code class="pcalibre3 calibre13 pcalibre4">apply</code>方法，就只能写成<code class="pcalibre3 calibre13 pcalibre4">Function.prototype.apply.call(fn, obj, args)</code>，采用<code class="pcalibre3 calibre13 pcalibre4">Reflect</code>对象可以简化这种操作。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> ages = [<span class="hljs-number">11</span>, <span class="hljs-number">33</span>, <span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">96</span>];

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-keyword">const</span> youngest = <span class="hljs-number">Math</span>.min.apply(<span class="hljs-number">Math</span>, ages);
<span class="hljs-keyword">const</span> oldest = <span class="hljs-number">Math</span>.max.apply(<span class="hljs-number">Math</span>, ages);
<span class="hljs-keyword">const</span> type = <span class="hljs-number">Object</span>.prototype.toString.call(youngest);

<span class="hljs-comment">// 新写法</span>
<span class="hljs-keyword">const</span> youngest = <span class="hljs-number">Reflect</span>.apply(<span class="hljs-number">Math</span>.min, <span class="hljs-number">Math</span>, ages);
<span class="hljs-keyword">const</span> oldest = <span class="hljs-number">Reflect</span>.apply(<span class="hljs-number">Math</span>.max, <span class="hljs-number">Math</span>, ages);
<span class="hljs-keyword">const</span> type = <span class="hljs-number">Reflect</span>.apply(<span class="hljs-number">Object</span>.prototype.toString, youngest, []);
</code></pre>
<h3 id="reflectdefinepropertytarget-propertykey-attributes" class="calibre11">Reflect.defineProperty(target, propertyKey, attributes)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty</code>方法基本等同于<code class="pcalibre3 calibre13 pcalibre4">Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty</code>代替它。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">MyDate</span>(<span class="hljs-number"></span>) </span>{
  <span class="hljs-comment">/*…*/</span>
}

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.defineProperty(MyDate, <span class="hljs-string">&#39;now&#39;</span>, {
  value: () =&gt; <span class="hljs-number">Date</span>.now()
});

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">&#39;now&#39;</span>, {
  value: () =&gt; <span class="hljs-number">Date</span>.now()
});
</code></pre>
<p class="calibre6">如果<code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>
<p class="calibre6">这个方法可以与<code class="pcalibre3 calibre13 pcalibre4">Proxy.defineProperty</code>配合使用。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-number">Proxy</span>({}, {
  defineProperty(target, prop, descriptor) {
    <span class="hljs-number">console</span>.log(descriptor);
    <span class="hljs-keyword">return</span> <span class="hljs-number">Reflect</span>.defineProperty(target, prop, descriptor);
  }
});

p.foo = <span class="hljs-string">&#39;bar&#39;</span>;
<span class="hljs-comment">// {value: &#34;bar&#34;, writable: true, enumerable: true, configurable: true}</span>

p.foo <span class="hljs-comment">// &#34;bar&#34;</span>
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code class="pcalibre3 calibre13 pcalibre4">Reflect.defineProperty</code>完成了赋值。</p>
<h3 id="reflectgetownpropertydescriptortarget-propertykey" class="calibre11">Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.getOwnPropertyDescriptor</code>基本等同于<code class="pcalibre3 calibre13 pcalibre4">Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {};
<span class="hljs-number">Object</span>.defineProperty(myObject, <span class="hljs-string">&#39;hidden&#39;</span>, {
  value: <span class="hljs-number">true</span>,
  enumerable: <span class="hljs-number">false</span>,
});

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-keyword">var</span> theDescriptor = <span class="hljs-number">Object</span>.getOwnPropertyDescriptor(myObject, <span class="hljs-string">&#39;hidden&#39;</span>);

<span class="hljs-comment">// 新写法</span>
<span class="hljs-keyword">var</span> theDescriptor = <span class="hljs-number">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="hljs-string">&#39;hidden&#39;</span>);
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.getOwnPropertyDescriptor</code>和<code class="pcalibre3 calibre13 pcalibre4">Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code class="pcalibre3 calibre13 pcalibre4">undefined</code>，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>
<h3 id="reflectisextensible-target" class="calibre11">Reflect.isExtensible (target)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.isExtensible</code>方法对应<code class="pcalibre3 calibre13 pcalibre4">Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> myObject = {};

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.isExtensible(myObject) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.isExtensible(myObject) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">如果参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Object.isExtensible</code>会返回<code class="pcalibre3 calibre13 pcalibre4">false</code>，因为非对象本来就是不可扩展的，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.isExtensible</code>会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Object</span>.isExtensible(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span>
<span class="hljs-number">Reflect</span>.isExtensible(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="reflectpreventextensionstarget" class="calibre11">Reflect.preventExtensions(target)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.preventExtensions</code>对应<code class="pcalibre3 calibre13 pcalibre4">Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {};

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.preventExtensions(myObject) <span class="hljs-comment">// Object {}</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.preventExtensions(myObject) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">如果参数不是对象，<code class="pcalibre3 calibre13 pcalibre4">Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code class="pcalibre3 calibre13 pcalibre4">Reflect.preventExtensions</code>会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// ES5 环境</span>
<span class="hljs-number">Object</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span>

<span class="hljs-comment">// ES6 环境</span>
<span class="hljs-number">Object</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="reflectownkeys-target" class="calibre11">Reflect.ownKeys (target)</h3>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code class="pcalibre3 calibre13 pcalibre4">Object.getOwnPropertyNames</code>与<code class="pcalibre3 calibre13 pcalibre4">Object.getOwnPropertySymbols</code>之和。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>,
  [<span class="hljs-number">Symbol</span>.for(<span class="hljs-string">&#39;baz&#39;</span>)]: <span class="hljs-number">3</span>,
  [<span class="hljs-number">Symbol</span>.for(<span class="hljs-string">&#39;bing&#39;</span>)]: <span class="hljs-number">4</span>,
};

<span class="hljs-comment">// 旧写法</span>
<span class="hljs-number">Object</span>.getOwnPropertyNames(myObject)
<span class="hljs-comment">// [&#39;foo&#39;, &#39;bar&#39;]</span>

<span class="hljs-number">Object</span>.getOwnPropertySymbols(myObject)
<span class="hljs-comment">//[Symbol(baz), Symbol(bing)]</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-number">Reflect</span>.ownKeys(myObject)
<span class="hljs-comment">// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]</span>
</code></pre>
<h2 id="实例：使用-proxy-实现观察者模式" class="calibre12">实例：使用 Proxy 实现观察者模式</h2>
<p class="calibre6">观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> person = observable({
  name: <span class="hljs-string">&#39;张三&#39;</span>,
  age: <span class="hljs-number">20</span>
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">print</span>(<span class="hljs-number"></span>) </span>{
  <span class="hljs-number">console</span>.log(<span class="hljs-string">`<span class="hljs-_">${person.name}</span>, <span class="hljs-_">${person.age}</span>`</span>)
}

observe(print);
person.name = <span class="hljs-string">&#39;李四&#39;</span>;
<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// 李四, 20</span>
</code></pre>
<p class="calibre6">上面代码中，数据对象<code class="pcalibre3 calibre13 pcalibre4">person</code>是观察目标，函数<code class="pcalibre3 calibre13 pcalibre4">print</code>是观察者。一旦数据对象发生变化，<code class="pcalibre3 calibre13 pcalibre4">print</code>就会自动执行。</p>
<p class="calibre6">下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code class="pcalibre3 calibre13 pcalibre4">observable</code>和<code class="pcalibre3 calibre13 pcalibre4">observe</code>这两个函数。思路是<code class="pcalibre3 calibre13 pcalibre4">observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> queuedObservers = <span class="hljs-keyword">new</span> <span class="hljs-number">Set</span>();

<span class="hljs-keyword">const</span> observe = fn =&gt; queuedObservers.add(fn);
<span class="hljs-keyword">const</span> observable = obj =&gt; <span class="hljs-keyword">new</span> <span class="hljs-number">Proxy</span>(obj, {set});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">set</span>(<span class="hljs-number">target, key, value, receiver</span>) </span>{
  <span class="hljs-keyword">const</span> result = <span class="hljs-number">Reflect</span>.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p class="calibre6">上面代码中，先定义了一个<code class="pcalibre3 calibre13 pcalibre4">Set</code>集合，所有观察者函数都放进这个集合。然后，<code class="pcalibre3 calibre13 pcalibre4">observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code class="pcalibre3 calibre13 pcalibre4">set</code>之中，会自动执行所有观察者。</p>

        </div>
    
</div>

        
    




                            </section>
                            <!--
                            <footer class="page-footer">
                                    <span class="copyright">
                                        Copyright © jim.plus 2017-2018 all right reserved, powered by Gitbook
                                    </span>
                                    <span class="footer-modification">
                                        Updated at 2018-03-29T13:58:14+08:00
                                    </span>
                            </footer>
                            -->
                        </div>
                        <div class="search-results">
                            <div class="has-results">
                                <h1 class="search-results-title">
                                    <span class='search-results-count'></span>
                                    results matching "<span class='search-query'></span>"
                                </h1>
                                <ul class="search-results-list"></ul>
                            </div>
                            <div class="no-results">
                                <h1 class="search-results-title">
                                    No results matching "<span class='search-query'></span>"
                                </h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <a href="proxy.html" class="navigation navigation-prev"
           aria-label="Previous page: 13. Proxy">
            <i class="fa fa-angle-left"></i>
        </a>
        <a href="promise.html" class="navigation navigation-next"
           aria-label="Next page: 15. Promise 对象">
            <i class="fa fa-angle-right"></i>
        </a>
    </div>

    <div class="back-to-top" style="display: block;"><i class="fa fa-arrow-up"></i></div>
    <script>
        var gitbook = gitbook || [];
        gitbook.push(function () {
            gitbook.page.hasChanged({
                "page": {
                    "title": "Changes",
                    "level": "2.1",
                    "depth": 1,
                    "next": {
                        "title": "15. Promise 对象",
                        "level": "2.2",
                        "depth": 1,
                        "path": "next.md",
                        "ref": "next.md",
                        "articles": []
                    },
                    "previous": {
                        "title": "13. Proxy",
                        "level": "1.1",
                        "depth": 1,
                        "path": "prev.md",
                        "ref": "prev.md",
                        "articles": []
                    },
                    "dir": "ltr"
                },
                "config": {
                    "gitbook": "*",
                    "theme": "default",
                    "variables": {},
                    "plugins": [],
                    "pluginsConfig": {
                        "highlight": {},
                        "search": {},
                        "lunr": {"maxIndexSize": 1000000, "ignoreSpecialCharacters": false},
                        "sharing": {
                            "facebook": true,
                            "twitter": true,
                            "google": false,
                            "weibo": false,
                            "instapaper": false,
                            "vk": false,
                            "all": ["facebook", "google", "twitter", "weibo", "instapaper"]
                        },
                        "fontsettings": {"theme": "white", "family": "sans", "size": 2},
                        "theme-default": {
                            "styles": {
                                "website": "styles/website.css",
                                "pdf": "styles/pdf.css",
                                "epub": "styles/epub.css",
                                "mobi": "styles/mobi.css",
                                "ebook": "styles/ebook.css",
                                "print": "styles/print.css"
                            }, "showLevel": false
                        }
                    },
                    "structure": {
                        "langs": "LANGS.md",
                        "readme": "README.md",
                        "glossary": "GLOSSARY.md",
                        "summary": "SUMMARY.md"
                    },
                    "pdf": {
                        "pageNumbers": true,
                        "fontSize": 12,
                        "fontFamily": "Arial",
                        "paperSize": "a4",
                        "chapterMark": "pagebreak",
                        "pageBreaksBefore": "/",
                        "margin": {"right": 62, "left": 62, "top": 56, "bottom": 56}
                    },
                    "styles": {
                        "website": "styles/website.css",
                        "pdf": "styles/pdf.css",
                        "epub": "styles/epub.css",
                        "mobi": "styles/mobi.css",
                        "ebook": "styles/ebook.css",
                        "print": "styles/print.css"
                    }
                },
                "file": {"path": "content.md", "mtime": "2018-03-02T08:30:36.677Z", "type": "markdown"},
                "gitbook": {"version": "3.2.3", "time": "2018-03-02T08:32:31.453Z"},
                "basePath": ".",
                "book": {"language": ""}
            });
        });
    </script>
</div>
<script src="https://cdn.jim.plus/gitbook/gitbook.js"></script>
<script src="https://cdn.jim.plus/gitbook/theme.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
<!--
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
-->
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-sharing/buttons.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-splitter/splitter.js"></script>
</body>
</html>