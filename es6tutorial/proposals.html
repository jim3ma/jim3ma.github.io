<!DOCTYPE HTML>
<html lang="">
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>30. 最新提案</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="description" content="">
    <meta name="generator" content="GitBook 3.2.3">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/style.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-page-toc-button/plugin.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-highlight/website.css">
    <!--
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search.css">
    -->
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/search.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-fontsettings/website.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
    <link rel="stylesheet" href="https://cdn.jim.plus/gitbook/gitbook-plugin-splitter/splitter.css">
    <link href="page_styles.css" rel="stylesheet" type="text/css"><link href="stylesheet.css" rel="stylesheet" type="text/css">
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152"
          href="https://cdn.jim.plus/gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://cdn.jim.plus/gitbook/images/favicon.ico" type="image/x-icon">
    <link rel="next" href="reference.html"/>
    <link rel="prev" href="arraybuffer.html"/>
</head>
<body>
<div class="book">
    <div class="book-summary">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search"/>
        </div>
    <nav role="navigation">
    <ul class="summary">
<li class="chapter" data-level="1" data-path="titlepage.html">
    <a href="titlepage.html">Cover</a>
</li>
<li class="chapter" data-level="2" data-path="SUMMARY.html">
    <a href="SUMMARY.html">Table of Contents</a>
</li>
<li class="chapter" data-level="3" data-path="index.html">
    <a href="index.html">0. 前言</a>
</li>
<li class="chapter" data-level="4" data-path="intro.html">
    <a href="intro.html">1. ECMAScript 6简介</a>
</li>
<li class="chapter" data-level="5" data-path="let.html">
    <a href="let.html">2. let 和 const 命令</a>
</li>
<li class="chapter" data-level="6" data-path="destructuring.html">
    <a href="destructuring.html">3. 变量的解构赋值</a>
</li>
<li class="chapter" data-level="7" data-path="string.html">
    <a href="string.html">4. 字符串的扩展</a>
</li>
<li class="chapter" data-level="8" data-path="regex.html">
    <a href="regex.html">5. 正则的扩展</a>
</li>
<li class="chapter" data-level="9" data-path="number.html">
    <a href="number.html">6. 数值的扩展</a>
</li>
<li class="chapter" data-level="10" data-path="function.html">
    <a href="function.html">7. 函数的扩展</a>
</li>
<li class="chapter" data-level="11" data-path="fp.html">
    <a href="fp.html">8. 函数式编程</a>
</li>
<li class="chapter" data-level="12" data-path="array.html">
    <a href="array.html">9. 数组的扩展</a>
</li>
<li class="chapter" data-level="13" data-path="object.html">
    <a href="object.html">10. 对象的扩展</a>
</li>
<li class="chapter" data-level="14" data-path="symbol.html">
    <a href="symbol.html">11. Symbol</a>
</li>
<li class="chapter" data-level="15" data-path="set-map.html">
    <a href="set-map.html">12. Set 和 Map 数据结构</a>
</li>
<li class="chapter" data-level="16" data-path="proxy.html">
    <a href="proxy.html">13. Proxy</a>
</li>
<li class="chapter" data-level="17" data-path="reflect.html">
    <a href="reflect.html">14. Reflect</a>
</li>
<li class="chapter" data-level="18" data-path="promise.html">
    <a href="promise.html">15. Promise 对象</a>
</li>
<li class="chapter" data-level="19" data-path="iterator.html">
    <a href="iterator.html">16. Iterator 和 for...of 循环</a>
</li>
<li class="chapter" data-level="20" data-path="generator.html">
    <a href="generator.html">17. Generator 函数的语法</a>
</li>
<li class="chapter" data-level="21" data-path="generator-async.html">
    <a href="generator-async.html">18. Generator 函数的异步应用</a>
</li>
<li class="chapter" data-level="22" data-path="async.html">
    <a href="async.html">19. async 函数</a>
</li>
<li class="chapter" data-level="23" data-path="class.html">
    <a href="class.html">20. Class 的基本语法</a>
</li>
<li class="chapter" data-level="24" data-path="class-extends.html">
    <a href="class-extends.html">21. Class 的继承</a>
</li>
<li class="chapter" data-level="25" data-path="mixin.html">
    <a href="mixin.html">22. Mixin</a>
</li>
<li class="chapter" data-level="26" data-path="simd.html">
    <a href="simd.html">23. SIMD</a>
</li>
<li class="chapter" data-level="27" data-path="decorator.html">
    <a href="decorator.html">24. Decorator</a>
</li>
<li class="chapter" data-level="28" data-path="module.html">
    <a href="module.html">25. Module 的语法</a>
</li>
<li class="chapter" data-level="29" data-path="module-loader.html">
    <a href="module-loader.html">26. Module 的加载实现</a>
</li>
<li class="chapter" data-level="30" data-path="style.html">
    <a href="style.html">27. 编程风格</a>
</li>
<li class="chapter" data-level="31" data-path="spec.html">
    <a href="spec.html">28. 读懂规格</a>
</li>
<li class="chapter" data-level="32" data-path="arraybuffer.html">
    <a href="arraybuffer.html">29. ArrayBuffer</a>
</li>
<li class="chapter" data-level="33" data-path="proposals.html">
    <a href="proposals.html">30. 最新提案</a>
</li>
<li class="chapter" data-level="34" data-path="reference.html">
    <a href="reference.html">31. 参考链接</a>
</li>
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                Published with GitBook
            </a>
        </li>
    </ul>
</nav>
    </div>
    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
                <!-- Title -->
                <h1>
                    <i class="fa fa-circle-o-notch fa-spin"></i>
                    <a href="proposals.html">30. 最新提案</a>
                </h1>
            </div>
            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                    <div id="book-search-results">
                        <div class="search-noresults">
                            <section class="normal markdown-section">
                            <div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_31">30. 最新提案</h1>
        <div class="section">
            <h1 id="最新提案" class="calibre5">最新提案</h1>
<p class="calibre6">本章介绍一些尚未进入标准、但很有希望的最新提案。</p>
<h2 id="do-表达式" class="calibre12">do 表达式</h2>
<p class="calibre6">本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">{
  <span class="hljs-keyword">let</span> t = f();
  t = t * t + <span class="hljs-number">1</span>;
}
</code></pre>
<p class="calibre6">上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到<code class="pcalibre3 calibre13 pcalibre4">t</code>的值，因为块级作用域不返回值，除非<code class="pcalibre3 calibre13 pcalibre4">t</code>是全局变量。</p>
<p class="calibre6">现在有一个<a href="https://github.com/tc39/proposal-do-expressions" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上<code class="pcalibre3 calibre13 pcalibre4">do</code>，使它变为<code class="pcalibre3 calibre13 pcalibre4">do</code>表达式，然后就会返回内部最后执行的表达式的值。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> t = f();
  t * t + <span class="hljs-number">1</span>;
};
</code></pre>
<p class="calibre6">上面代码中，变量<code class="pcalibre3 calibre13 pcalibre4">x</code>会得到整个块级作用域的返回值（<code class="pcalibre3 calibre13 pcalibre4">t * t + 1</code>）。</p>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">do</code>表达式的逻辑非常简单：封装的是什么，就会返回什么。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 等同于 &lt;表达式&gt;</span>
<span class="hljs-keyword">do</span> { <span class="hljs-_"><span class="hljs-tag">&lt;<span class="hljs-_">表达式</span>&gt;</span>; }

// 等同于 <span class="hljs-tag">&lt;<span class="hljs-_">语句</span>&gt;</span>
do { <span class="hljs-tag">&lt;<span class="hljs-_">语句</span>&gt;</span> }
</span></code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">do</code>表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">if</span> (foo()) { f() }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bar()) { g() }
  <span class="hljs-keyword">else</span> { h() }
};
</code></pre>
<p class="calibre6">上面代码的本质，就是根据函数<code class="pcalibre3 calibre13 pcalibre4">foo</code>的执行结果，调用不同的函数，将返回结果赋给变量<code class="pcalibre3 calibre13 pcalibre4">x</code>。使用<code class="pcalibre3 calibre13 pcalibre4">do</code>表达式，就将这个操作的意图表达得非常简洁清晰。而且，<code class="pcalibre3 calibre13 pcalibre4">do</code>块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝。</p>
<p class="calibre6">值得一提的是，<code class="pcalibre3 calibre13 pcalibre4">do</code>表达式在 JSX 语法中非常好用。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">return</span> (
  &lt;nav&gt;
    &lt;Home /&gt;
    {
      do {
        if (loggedIn) {
          &lt;LogoutButton /&gt;
        } else {
          &lt;LoginButton /&gt;
        }
      }
    }
  &lt;/nav&gt;
)
</code></pre>
<p class="calibre6">上面代码中，如果不用<code class="pcalibre3 calibre13 pcalibre4">do</code>表达式，就只能用三元判断运算符（<code class="pcalibre3 calibre13 pcalibre4">?:</code>）。那样的话，一旦判断逻辑复杂，代码就会变得很不易读。</p>
<h2 id="throw-表达式" class="calibre12">throw 表达式</h2>
<p class="calibre6">JavaScript 语法规定<code class="pcalibre3 calibre13 pcalibre4">throw</code>是一个命令，用来抛出错误，不能用于表达式之中。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 报错</span>
<span class="hljs-number">console</span>.log(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-number">Error</span>());
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">console.log</code>的参数必须是一个表达式，如果是一个<code class="pcalibre3 calibre13 pcalibre4">throw</code>语句就会报错。</p>
<p class="calibre6">现在有一个<a href="https://github.com/tc39/proposal-throw-expressions" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，允许<code class="pcalibre3 calibre13 pcalibre4">throw</code>用于表达式。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 参数的默认值</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">save</span>(<span class="hljs-number">filename = throw new TypeError(&#34;Argument required&#34;</span>)) </span>{
}

<span class="hljs-comment">// 箭头函数的返回值</span>
lint(ast, {
  <span class="hljs-keyword">with</span>: () =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-number">Error</span>(<span class="hljs-string">&#34;avoid using &#39;with&#39; statements.&#34;</span>)
});

<span class="hljs-comment">// 条件表达式</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getEncoder</span>(<span class="hljs-number">encoding</span>) </span>{
  <span class="hljs-keyword">const</span> encoder = encoding === <span class="hljs-string">&#34;utf8&#34;</span> ?
    <span class="hljs-keyword">new</span> UTF8Encoder() :
    encoding === <span class="hljs-string">&#34;utf16le&#34;</span> ?
      <span class="hljs-keyword">new</span> UTF16Encoder(<span class="hljs-number">false</span>) :
      encoding === <span class="hljs-string">&#34;utf16be&#34;</span> ?
        <span class="hljs-keyword">new</span> UTF16Encoder(<span class="hljs-number">true</span>) :
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-number">Error</span>(<span class="hljs-string">&#34;Unsupported encoding&#34;</span>);
}

<span class="hljs-comment">// 逻辑表达式</span>
<span class="hljs-_"><span class="hljs-keyword">class</span> <span class="hljs-comment">Product</span> </span>{
  get id() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id;
  }
  set id(value) {
    <span class="hljs-keyword">this</span>._id = value || <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-number">Error</span>(<span class="hljs-string">&#34;Invalid value&#34;</span>);
  }
}
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">throw</code>都出现在表达式里面。</p>
<p class="calibre6">语法上，<code class="pcalibre3 calibre13 pcalibre4">throw</code>表达式里面的<code class="pcalibre3 calibre13 pcalibre4">throw</code>不再是一个命令，而是一个运算符。为了避免与<code class="pcalibre3 calibre13 pcalibre4">throw</code>命令混淆，规定<code class="pcalibre3 calibre13 pcalibre4">throw</code>出现在行首，一律解释为<code class="pcalibre3 calibre13 pcalibre4">throw</code>语句，而不是<code class="pcalibre3 calibre13 pcalibre4">throw</code>表达式。</p>
<h2 id="链判断运算符" class="calibre12">链判断运算符</h2>
<p class="calibre6">编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code class="pcalibre3 calibre13 pcalibre4">message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> firstName = (message
  &amp;&amp; message.body
  &amp;&amp; message.body.user
  &amp;&amp; message.body.user.firstName) || <span class="hljs-string">&#39;default&#39;</span>;
</code></pre>
<p class="calibre6">这样的层层判断非常麻烦，因此现在有一个<a href="https://github.com/tc39/proposal-optional-chaining" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，引入了“链判断运算符”（optional chaining operator）<code class="pcalibre3 calibre13 pcalibre4">?.</code>，简化上面的写法。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> firstName = message?.body?.user?.firstName || <span class="hljs-string">&#39;default&#39;</span>;
</code></pre>
<p class="calibre6">上面代码有三个<code class="pcalibre3 calibre13 pcalibre4">?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code class="pcalibre3 calibre13 pcalibre4">null</code>或<code class="pcalibre3 calibre13 pcalibre4">undefined</code>。如果是的，就不再往下运算，而是返回<code class="pcalibre3 calibre13 pcalibre4">undefined</code>。</p>
<p class="calibre6">链判断运算符号有三种用法。</p>
<ul class="calibre9">
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">obj?.prop</code> // 读取对象属性</li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">obj?.[expr]</code> // 同上</li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<p class="calibre6">下面是判断函数是否存在的例子。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">iterator.return?.()
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">iterator.return</code>如果有定义，就会调用该方法，否则直接返回<code class="pcalibre3 calibre13 pcalibre4">undefined</code>。</p>
<p class="calibre6">下面是更多的例子。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">a?.b
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : a.b

a?.[x]
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : a[x]

a?.b()
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : a.b()

a?.()
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : a()
</code></pre>
<p class="calibre6">使用这个运算符，有几个注意点。</p>
<p class="calibre6">（1）短路机制</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">a?.[++x]
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : a[++x]
</code></pre>
<p class="calibre6">上面代码中，如果<code class="pcalibre3 calibre13 pcalibre4">a</code>是<code class="pcalibre3 calibre13 pcalibre4">undefined</code>或<code class="pcalibre3 calibre13 pcalibre4">null</code>，那么<code class="pcalibre3 calibre13 pcalibre4">x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>
<p class="calibre6">（2）delete 运算符</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">delete</span> a?.b
<span class="hljs-comment">// 等同于</span>
a == <span class="hljs-number">null</span> ? <span class="hljs-number">undefined</span> : <span class="hljs-keyword">delete</span> a.b
</code></pre>
<p class="calibre6">上面代码中，如果<code class="pcalibre3 calibre13 pcalibre4">a</code>是<code class="pcalibre3 calibre13 pcalibre4">undefined</code>或<code class="pcalibre3 calibre13 pcalibre4">null</code>，会直接返回<code class="pcalibre3 calibre13 pcalibre4">undefined</code>，而不会进行<code class="pcalibre3 calibre13 pcalibre4">delete</code>运算。</p>
<p class="calibre6">（3）报错场合</p>
<p class="calibre6">以下写法是禁止，会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 构造函数判断</span>
<span class="hljs-keyword">new</span> a?.()

<span class="hljs-comment">// 运算符右侧是模板字符串</span>
a?.<span class="hljs-string">`{b}`</span>

<span class="hljs-comment">// 链判断运算符前后有构造函数或模板字符串</span>
<span class="hljs-keyword">new</span> a?.b()
a?.b<span class="hljs-string">`{c}`</span>

<span class="hljs-comment">// 链运算符用于赋值运算符左侧</span>
a?.b = c
</code></pre>
<p class="calibre6">（4）右侧不得为十进制数值</p>
<p class="calibre6">为了保证兼容以前的代码，允许<code class="pcalibre3 calibre13 pcalibre4">foo?.3:0</code>被解析成<code class="pcalibre3 calibre13 pcalibre4">foo ? .3 : 0</code>，因此规定如果<code class="pcalibre3 calibre13 pcalibre4">?.</code>后面紧跟一个十进制数字，那么<code class="pcalibre3 calibre13 pcalibre4">?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
<h2 id="直接输入-u2028-和-u2029" class="calibre12">直接输入 U+2028 和 U+2029</h2>
<p class="calibre6">JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式<code class="pcalibre3 calibre13 pcalibre4">\u4e2d</code>，两者是等价的。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-string">&#39;中&#39;</span> === <span class="hljs-string">&#39;\u4e2d&#39;</span> <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>
<ul class="calibre9">
<li class="calibre10">U+005C：反斜杠（reverse solidus)</li>
<li class="calibre10">U+000D：回车（carriage return）</li>
<li class="calibre10">U+2028：行分隔符（line separator）</li>
<li class="calibre10">U+2029：段分隔符（paragraph separator）</li>
<li class="calibre10">U+000A：换行符（line feed）</li>
</ul>
<p class="calibre6">举例来说，字符串里面不能直接包含反斜杠，一定要转义写成<code class="pcalibre3 calibre13 pcalibre4">\\</code>或者<code class="pcalibre3 calibre13 pcalibre4">\u005c</code>。</p>
<p class="calibre6">这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被<code class="pcalibre3 calibre13 pcalibre4">JSON.parse</code>解析，就有可能直接报错。</p>
<p class="calibre6">JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，现在有一个<a href="https://github.com/tc39/proposal-json-superset" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> PS = <span class="hljs-number">eval</span>(<span class="hljs-string">&#34;&#39;\u2029&#39;&#34;</span>);
</code></pre>
<p class="calibre6">根据这个提案，上面的代码不会报错。</p>
<p class="calibre6">注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。</p>
<h2 id="函数的部分执行" class="calibre12">函数的部分执行</h2>
<h3 id="语法" class="calibre11">语法</h3>
<p class="calibre6">多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">add</span>(<span class="hljs-number">x, y</span>) </span>{ <span class="hljs-keyword">return</span> x + y; }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">add7</span>(<span class="hljs-number">x</span>) </span>{ <span class="hljs-keyword">return</span> x + <span class="hljs-number">7</span>; }
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">add7</code>函数其实是<code class="pcalibre3 calibre13 pcalibre4">add</code>函数的一个特殊版本，通过将一个参数绑定为<code class="pcalibre3 calibre13 pcalibre4">7</code>，就可以从<code class="pcalibre3 calibre13 pcalibre4">add</code>得到<code class="pcalibre3 calibre13 pcalibre4">add7</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// bind 方法</span>
<span class="hljs-keyword">const</span> add7 = add.bind(<span class="hljs-number">null</span>, <span class="hljs-number">7</span>);

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> add7 = x =&gt; add(x, <span class="hljs-number">7</span>);
</code></pre>
<p class="calibre6">上面两种写法都有些冗余。其中，<code class="pcalibre3 calibre13 pcalibre4">bind</code>方法的局限更加明显，它必须提供<code class="pcalibre3 calibre13 pcalibre4">this</code>，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。</p>
<p class="calibre6">现在有一个<a href="https://github.com/tc39/proposal-partial-application" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> add = (x, y) =&gt; x + y;
<span class="hljs-keyword">const</span> addOne = add(<span class="hljs-number">1</span>, ?);

<span class="hljs-keyword">const</span> maxGreaterThanZero = <span class="hljs-number">Math</span>.max(<span class="hljs-number">0</span>, ...);
</code></pre>
<p class="calibre6">根据新提案，<code class="pcalibre3 calibre13 pcalibre4">?</code>是单个参数的占位符，<code class="pcalibre3 calibre13 pcalibre4">...</code>是多个参数的占位符。以下的形式都属于函数的部分执行。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">f(x, ?)
f(x, ...)
f(?, x)
f(..., x)
f(?, x, ?)
f(..., x, ...)
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">?</code>和<code class="pcalibre3 calibre13 pcalibre4">...</code>只能出现在函数的调用之中，并且会返回一个新函数。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> g = f(?, <span class="hljs-number">1</span>, ...);
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">const</span> g = (x, ...y) =&gt; f(x, <span class="hljs-number">1</span>, ...y);
</code></pre>
<p class="calibre6">函数的部分执行，也可以用于对象的方法。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> obj = {
  f(x, y) { <span class="hljs-keyword">return</span> x + y; },
};

<span class="hljs-keyword">const</span> g = obj.f(?, <span class="hljs-number">3</span>);
g(<span class="hljs-number">1</span>) <span class="hljs-comment">// 4</span>
</code></pre>
<h3 id="注意点" class="calibre11">注意点</h3>
<p class="calibre6">函数的部分执行有一些特别注意的地方。</p>
<p class="calibre6">（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> f = (x, y) =&gt; x + y;

<span class="hljs-keyword">const</span> g = f(?, <span class="hljs-number">3</span>);
g(<span class="hljs-number">1</span>); <span class="hljs-comment">// 4</span>

<span class="hljs-comment">// 替换函数 f</span>
f = (x, y) =&gt; x * y;

g(<span class="hljs-number">1</span>); <span class="hljs-comment">// 3</span>
</code></pre>
<p class="calibre6">上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。</p>
<p class="calibre6">（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> f = (x, y) =&gt; x + y;

<span class="hljs-keyword">const</span> g = f(?, a);
g(<span class="hljs-number">1</span>); <span class="hljs-comment">// 4</span>

<span class="hljs-comment">// 改变 a 的值</span>
a = <span class="hljs-number">10</span>;
g(<span class="hljs-number">1</span>); <span class="hljs-comment">// 11</span>
</code></pre>
<p class="calibre6">上面代码中，预先提供的参数是变量<code class="pcalibre3 calibre13 pcalibre4">a</code>，那么每次调用函数<code class="pcalibre3 calibre13 pcalibre4">g</code>的时候，才会对<code class="pcalibre3 calibre13 pcalibre4">a</code>进行求值。</p>
<p class="calibre6">（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> f = (x, ...y) =&gt; [x, ...y];
<span class="hljs-keyword">const</span> g = f(?, <span class="hljs-number">1</span>);
g(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// [2, 1]</span>
</code></pre>
<p class="calibre6">上面代码中，函数<code class="pcalibre3 calibre13 pcalibre4">g</code>只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。</p>
<p class="calibre6">写成下面这样，多余的参数就没有问题。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> f = (x, ...y) =&gt; [x, ...y];
<span class="hljs-keyword">const</span> g = f(?, <span class="hljs-number">1</span>, ...);
g(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// [2, 1, 3, 4];</span>
</code></pre>
<p class="calibre6">（4）<code class="pcalibre3 calibre13 pcalibre4">...</code>只会被采集一次，如果函数的部分执行使用了多个<code class="pcalibre3 calibre13 pcalibre4">...</code>，那么每个<code class="pcalibre3 calibre13 pcalibre4">...</code>的值都将相同。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">const</span> f = (...x) =&gt; x;
<span class="hljs-keyword">const</span> g = f(..., <span class="hljs-number">9</span>, ...);
g(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3, 9, 1, 2, 3]</span>
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">g</code>定义了两个<code class="pcalibre3 calibre13 pcalibre4">...</code>占位符，真正执行的时候，它们的值是一样的。</p>
<h2 id="管道运算符" class="calibre12">管道运算符</h2>
<p class="calibre6">Unix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，现在有一个<a href="https://github.com/tc39/proposal-pipeline-operator" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，让 JavaScript 也拥有管道机制。</p>
<p class="calibre6">JavaScript 的管道是一个运算符，写作<code class="pcalibre3 calibre13 pcalibre4">|&gt;</code>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">x |&gt; f
<span class="hljs-comment">// 等同于</span>
f(x)
</code></pre>
<p class="calibre6">管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">doubleSay</span> (<span class="hljs-number">str</span>) </span>{
  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#34;, &#34;</span> + str;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">capitalize</span> (<span class="hljs-number">str</span>) </span>{
  <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>].toUpperCase() + str.substring(<span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">exclaim</span> (<span class="hljs-number">str</span>) </span>{
  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#39;!&#39;</span>;
}
</code></pre>
<p class="calibre6">上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 传统的写法</span>
exclaim(capitalize(doubleSay(<span class="hljs-string">&#39;hello&#39;</span>)))
<span class="hljs-comment">// &#34;Hello, hello!&#34;</span>

<span class="hljs-comment">// 管道的写法</span>
<span class="hljs-string">&#39;hello&#39;</span>
  |&gt; doubleSay
  |&gt; capitalize
  |&gt; exclaim
<span class="hljs-comment">// &#34;Hello, hello!&#34;</span>
</code></pre>
<p class="calibre6">管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">double</span> (<span class="hljs-number">x</span>) </span>{ <span class="hljs-keyword">return</span> x + x; }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">add</span> (<span class="hljs-number">x, y</span>) </span>{ <span class="hljs-keyword">return</span> x + y; }

<span class="hljs-keyword">let</span> person = { score: <span class="hljs-number">25</span> };
person.score
  |&gt; double
  |&gt; (_ =&gt; add(<span class="hljs-number">7</span>, _))
<span class="hljs-comment">// 57</span>
</code></pre>
<p class="calibre6">上面代码中，<code class="pcalibre3 calibre13 pcalibre4">add</code>函数需要两个参数。但是，管道运算符只能传入一个值，因此需要事先提供另一个参数，并将其改成单参数的箭头函数<code class="pcalibre3 calibre13 pcalibre4">_ =&gt; add(7, _)</code>。这个函数里面的下划线并没有特别的含义，可以用其他符号代替，使用下划线只是因为，它能够形象地表示这里是占位符。</p>
<p class="calibre6">管道运算符对于<code class="pcalibre3 calibre13 pcalibre4">await</code>函数也适用。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">x |&gt; <span class="hljs-keyword">await</span> f
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">await</span> f(x)

<span class="hljs-keyword">const</span> userAge = userId |&gt; <span class="hljs-keyword">await</span> fetchUserById |&gt; getAgeFromUser;
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">const</span> userAge = getAgeFromUser(<span class="hljs-keyword">await</span> fetchUserById(userId));
</code></pre>
<h2 id="数值分隔符" class="calibre12">数值分隔符</h2>
<p class="calibre6">欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，<code class="pcalibre3 calibre13 pcalibre4">1000</code>可以写作<code class="pcalibre3 calibre13 pcalibre4">1,000</code>。</p>
<p class="calibre6">现在有一个<a href="https://github.com/tc39/proposal-numeric-separator" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，允许 JavaScript 的数值使用下划线（<code class="pcalibre3 calibre13 pcalibre4">_</code>）作为分隔符。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">let</span> budget = <span class="hljs-number">1</span>_000_000_000_000;
budget === <span class="hljs-number">10</span> ** <span class="hljs-number">12</span> <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">JavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">123</span>_00 === <span class="hljs-number">12</span>_300 <span class="hljs-comment">// true</span>

<span class="hljs-number">12345</span>_00 === <span class="hljs-number">123</span>_4500 <span class="hljs-comment">// true</span>
<span class="hljs-number">12345</span>_00 === <span class="hljs-number">1</span>_234_500 <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">小数和科学计数法也可以使用数值分隔符。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 小数</span>
<span class="hljs-number">0.000</span>_001
<span class="hljs-comment">// 科学计数法</span>
<span class="hljs-number">1e10</span>_000
</code></pre>
<p class="calibre6">数值分隔符有几个使用注意点。</p>
<ul class="calibre9">
<li class="calibre10">不能在数值的最前面（leading）或最后面（trailing）。</li>
<li class="calibre10">不能两个或两个以上的分隔符连在一起。</li>
<li class="calibre10">小数点的前后不能有分隔符。</li>
<li class="calibre10">科学计数法里面，表示指数的<code class="pcalibre3 calibre13 pcalibre4">e</code>或<code class="pcalibre3 calibre13 pcalibre4">E</code>前后不能有分隔符。</li>
</ul>
<p class="calibre6">下面的写法都会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 全部报错</span>
<span class="hljs-number">3</span>_<span class="hljs-number">.141</span>
<span class="hljs-number">3.</span>_141
<span class="hljs-number">1</span>_e12
<span class="hljs-number">1</span>e_12
<span class="hljs-number">123</span>__456
_1464301
<span class="hljs-number">1464301</span>_
</code></pre>
<p class="calibre6">除了十进制，其他进制的数值也可以使用分隔符。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 二进制</span>
<span class="hljs-number">0b1010</span>_0001_1000_0101
<span class="hljs-comment">// 十六进制</span>
<span class="hljs-number">0xA0</span>_B0_C0
</code></pre>
<p class="calibre6">注意，分隔符不能紧跟着进制的前缀<code class="pcalibre3 calibre13 pcalibre4">0b</code>、<code class="pcalibre3 calibre13 pcalibre4">0B</code>、<code class="pcalibre3 calibre13 pcalibre4">0o</code>、<code class="pcalibre3 calibre13 pcalibre4">0O</code>、<code class="pcalibre3 calibre13 pcalibre4">0x</code>、<code class="pcalibre3 calibre13 pcalibre4">0X</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 报错</span>
<span class="hljs-number">0</span>_b111111000
<span class="hljs-number">0</span>b_111111000
</code></pre>
<p class="calibre6">下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p>
<ul class="calibre9">
<li class="calibre10">Number()</li>
<li class="calibre10">parseInt()</li>
<li class="calibre10">parseFloat()</li>
</ul>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Number</span>(<span class="hljs-string">&#39;123_456&#39;</span>) <span class="hljs-comment">// NaN</span>
<span class="hljs-number">parseInt</span>(<span class="hljs-string">&#39;123_456&#39;</span>) <span class="hljs-comment">// 123</span>
</code></pre>
<h2 id="bigint-数据类型" class="calibre12">BigInt 数据类型</h2>
<h3 id="简介" class="calibre11">简介</h3>
<p class="calibre6">JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code class="pcalibre3 calibre13 pcalibre4">Infinite</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 超过 53 个二进制位的数值，无法保持精度</span>
<span class="hljs-number">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) === <span class="hljs-number">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 超过 2 的 1024 次方的数值，无法表示</span>
<span class="hljs-number">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>) <span class="hljs-comment">// Infinity</span>
</code></pre>
<p class="calibre6">现在有一个<a href="https://github.com/tc39/proposal-bigint" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<p class="calibre6">为了与 Number 类型区别，BigInt 类型的数据必须使用后缀<code class="pcalibre3 calibre13 pcalibre4">n</code>表示。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">1234</span>n
<span class="hljs-number">1</span>n + <span class="hljs-number">2</span>n <span class="hljs-comment">// 3n</span>
</code></pre>
<p class="calibre6">BigInt 同样可以使用各种进制表示，都要加上后缀<code class="pcalibre3 calibre13 pcalibre4">n</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">0b1101</span>n <span class="hljs-comment">// 二进制</span>
<span class="hljs-number">0o777</span>n <span class="hljs-comment">// 八进制</span>
<span class="hljs-number">0xFF</span>n <span class="hljs-comment">// 十六进制</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">typeof</code>运算符对于 BigInt 类型的数据返回<code class="pcalibre3 calibre13 pcalibre4">bigint</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>n <span class="hljs-comment">// &#39;BigInt&#39;</span>
</code></pre>
<h3 id="bigint-对象" class="calibre11">BigInt 对象</h3>
<p class="calibre6">JavaScript 原生提供<code class="pcalibre3 calibre13 pcalibre4">BigInt</code>对象，可以用作构造函数生成 BitInt 类型的数值。转换规则基本与<code class="pcalibre3 calibre13 pcalibre4">Number()</code>一致，将别的类型的值转为 BigInt。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">BigInt(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123n</span>
BigInt(<span class="hljs-string">&#39;123&#39;</span>) <span class="hljs-comment">// 123n</span>
BitInt(<span class="hljs-number">false</span>) <span class="hljs-comment">// 0n</span>
BitInt(<span class="hljs-number">true</span>) <span class="hljs-comment">// 1n</span>
</code></pre>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">BitInt</code>构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-keyword">new</span> BitInt() <span class="hljs-comment">// TypeError</span>
BigInt(<span class="hljs-number">undefined</span>) <span class="hljs-comment">//TypeError</span>
BigInt(<span class="hljs-number">null</span>) <span class="hljs-comment">// TypeError</span>
BigInt(<span class="hljs-string">&#39;123n&#39;</span>) <span class="hljs-comment">// SyntaxError</span>
BigInt(<span class="hljs-string">&#39;abc&#39;</span>) <span class="hljs-comment">// SyntaxError</span>
</code></pre>
<p class="calibre6">上面代码中，尤其值得注意字符串<code class="pcalibre3 calibre13 pcalibre4">123n</code>无法解析成 Number 类型，所以会报错。</p>
<p class="calibre6">BigInt 对象继承了 Object 提供的实例方法。</p>
<ul class="calibre9">
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.prototype.toLocaleString()</code></li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.prototype.toString()</code></li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.prototype.valueOf()</code></li>
</ul>
<p class="calibre6">此外，还提供了三个静态方法。</p>
<ul class="calibre9">
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.asUintN(width, BigInt)</code>： 对给定的大整数，返回 0 到 2<sup class="calibre18">width</sup> - 1 之间的大整数形式。</li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.asIntN(width, BigInt)</code>：对给定的大整数，返回 -2<sup class="calibre18">width - 1</sup> 到 2<sup class="calibre18">width - 1</sup> - 1 之间的大整数形式。</li>
<li class="calibre10"><code class="pcalibre3 calibre13 pcalibre4">BigInt.parseInt(string[, radix])</code>：近似于<code class="pcalibre3 calibre13 pcalibre4">Number.parseInt</code>，将一个字符串转换成指定进制的大整数。</li>
</ul>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-comment">// 将一个大整数转为 64 位整数的形式</span>
<span class="hljs-keyword">const</span> int64a = BigInt.asUintN(<span class="hljs-number">64</span>, <span class="hljs-number">12345</span>n);

<span class="hljs-comment">// Number.parseInt 与 BigInt.parseInt 的对比</span>
<span class="hljs-number">Number</span>.parseInt(<span class="hljs-string">&#39;9007199254740993&#39;</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">// 9007199254740992</span>
BigInt.parseInt(<span class="hljs-string">&#39;9007199254740993&#39;</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">// 9007199254740993n</span>
</code></pre>
<p class="calibre6">上面代码中，由于有效数字超出了最大限度，<code class="pcalibre3 calibre13 pcalibre4">Number.parseInt</code>方法返回的结果是不精确的，而<code class="pcalibre3 calibre13 pcalibre4">BigInt.parseInt</code>方法正确返回了对应的大整数。</p>
<p class="calibre6">对于二进制数组，BigInt 新增了两个类型<code class="pcalibre3 calibre13 pcalibre4">BigUint64Array</code>和<code class="pcalibre3 calibre13 pcalibre4">BigInt64Array</code>，这两种数据类型返回的都是大整数。<code class="pcalibre3 calibre13 pcalibre4">DataView</code>对象的实例方法<code class="pcalibre3 calibre13 pcalibre4">DataView.prototype.getBigInt64</code>和<code class="pcalibre3 calibre13 pcalibre4">DataView.prototype.getBigUint64</code>，返回的也是大整数。</p>
<h3 id="运算" class="calibre11">运算</h3>
<p class="calibre6">数学运算方面，BigInt 类型的<code class="pcalibre3 calibre13 pcalibre4">+</code>、<code class="pcalibre3 calibre13 pcalibre4">-</code>、<code class="pcalibre3 calibre13 pcalibre4">*</code>和<code class="pcalibre3 calibre13 pcalibre4">**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code class="pcalibre3 calibre13 pcalibre4">/</code>会舍去小数部分，返回一个整数。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">9</span>n / <span class="hljs-number">5</span>n
<span class="hljs-comment">// 1n</span>
</code></pre>
<p class="calibre6">几乎所有的 Number 运算符都可以用在 BigInt，但是有两个除外：不带符号的右移位运算符<code class="pcalibre3 calibre13 pcalibre4">&gt;&gt;&gt;</code>和一元的求正运算符<code class="pcalibre3 calibre13 pcalibre4">+</code>，使用时会报错。前者是因为<code class="pcalibre3 calibre13 pcalibre4">&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code class="pcalibre3 calibre13 pcalibre4">&gt;&gt;</code>。后者是因为一元运算符<code class="pcalibre3 calibre13 pcalibre4">+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code class="pcalibre3 calibre13 pcalibre4">+1n</code>会报错。</p>
<p class="calibre6">Integer 类型不能与 Number 类型进行混合运算。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">1</span>n + <span class="hljs-number">1.3</span> <span class="hljs-comment">// 报错</span>
</code></pre>
<p class="calibre6">上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失信息。比如<code class="pcalibre3 calibre13 pcalibre4">(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code class="pcalibre3 calibre13 pcalibre4">0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>
<p class="calibre6">asm.js 里面，<code class="pcalibre3 calibre13 pcalibre4">|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code class="pcalibre3 calibre13 pcalibre4">|0</code>进行运算会报错。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">1</span>n | <span class="hljs-number">0</span> <span class="hljs-comment">// 报错</span>
</code></pre>
<p class="calibre6">相等运算符（<code class="pcalibre3 calibre13 pcalibre4">==</code>）会改变数据类型，也是不允许混合使用。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">0</span>n == <span class="hljs-number">0</span>
<span class="hljs-comment">// 报错 TypeError</span>

<span class="hljs-number">0</span>n == <span class="hljs-number">false</span>
<span class="hljs-comment">// 报错 TypeError</span>
</code></pre>
<p class="calibre6">精确相等运算符（<code class="pcalibre3 calibre13 pcalibre4">===</code>）不会改变数据类型，因此可以混合使用。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">0</span>n === <span class="hljs-number">0</span>
<span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre6">大整数可以转为其他数据类型。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Boolean</span>(<span class="hljs-number">0</span>n) <span class="hljs-comment">// false</span>
<span class="hljs-number">Boolean</span>(<span class="hljs-number">1</span>n) <span class="hljs-comment">// true</span>
<span class="hljs-number">Number</span>(<span class="hljs-number">1</span>n)  <span class="hljs-comment">// 1</span>
<span class="hljs-number">String</span>(<span class="hljs-number">1</span>n)  <span class="hljs-comment">// &#34;1&#34;</span>

!<span class="hljs-number">0</span>n <span class="hljs-comment">// true</span>
!<span class="hljs-number">1</span>n <span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre6">大整数也可以与字符串混合运算。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-string">&#39;&#39;</span> + <span class="hljs-number">123</span>n <span class="hljs-comment">// &#34;123&#34;</span>
</code></pre>
<h2 id="mathsignbit" class="calibre12">Math.signbit()</h2>
<p class="calibre6"><code class="pcalibre3 calibre13 pcalibre4">Math.sign()</code>用来判断一个值的正负，但是如果参数是<code class="pcalibre3 calibre13 pcalibre4">-0</code>，它会返回<code class="pcalibre3 calibre13 pcalibre4">-0</code>。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Math</span>.sign(<span class="hljs-number">-0</span>) <span class="hljs-comment">// -0</span>
</code></pre>
<p class="calibre6">这导致对于判断符号位的正负，<code class="pcalibre3 calibre13 pcalibre4">Math.sign()</code>不是很有用。JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，<code class="pcalibre3 calibre13 pcalibre4">0</code>表示正数，<code class="pcalibre3 calibre13 pcalibre4">1</code>表示负数。所以会有两种零，<code class="pcalibre3 calibre13 pcalibre4">+0</code>是符号位为<code class="pcalibre3 calibre13 pcalibre4">0</code>时的零值，<code class="pcalibre3 calibre13 pcalibre4">-0</code>是符号位为<code class="pcalibre3 calibre13 pcalibre4">1</code>时的零值。实际编程中，判断一个值是<code class="pcalibre3 calibre13 pcalibre4">+0</code>还是<code class="pcalibre3 calibre13 pcalibre4">-0</code>非常麻烦，因为它们是相等的。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6">+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span> <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre6">目前，有一个<a href="http://jfbastien.github.io/papers/Math.signbit.html" target="_blank" class="pcalibre pcalibre1 pcalibre2 calibre7">提案</a>，引入了<code class="pcalibre3 calibre13 pcalibre4">Math.signbit()</code>方法判断一个数的符号位是否设置了。</p>
<pre class="calibre14"><code class="pcalibre5 lang-bash pcalibre6"><span class="hljs-number">Math</span>.signbit(<span class="hljs-number">2</span>) <span class="hljs-comment">//false</span>
<span class="hljs-number">Math</span>.signbit(<span class="hljs-number">-2</span>) <span class="hljs-comment">//true</span>
<span class="hljs-number">Math</span>.signbit(<span class="hljs-number">0</span>) <span class="hljs-comment">//false</span>
<span class="hljs-number">Math</span>.signbit(<span class="hljs-number">-0</span>) <span class="hljs-comment">//true</span>
</code></pre>
<p class="calibre6">可以看到，该方法正确返回了<code class="pcalibre3 calibre13 pcalibre4">-0</code>的符号位是设置了的。</p>
<p class="calibre6">该方法的算法如下。</p>
<ul class="calibre9">
<li class="calibre10">如果参数是<code class="pcalibre3 calibre13 pcalibre4">NaN</code>，返回<code class="pcalibre3 calibre13 pcalibre4">false</code></li>
<li class="calibre10">如果参数是<code class="pcalibre3 calibre13 pcalibre4">-0</code>，返回<code class="pcalibre3 calibre13 pcalibre4">true</code></li>
<li class="calibre10">如果参数是负值，返回<code class="pcalibre3 calibre13 pcalibre4">true</code></li>
<li class="calibre10">其他情况返回<code class="pcalibre3 calibre13 pcalibre4">false</code></li>
</ul>

        </div>
    
</div>

        
    




                            </section>
                            <!--
                            <footer class="page-footer">
                                    <span class="copyright">
                                        Copyright © jim.plus 2017-2018 all right reserved, powered by Gitbook
                                    </span>
                                    <span class="footer-modification">
                                        Updated at 2018-03-29T13:58:14+08:00
                                    </span>
                            </footer>
                            -->
                        </div>
                        <div class="search-results">
                            <div class="has-results">
                                <h1 class="search-results-title">
                                    <span class='search-results-count'></span>
                                    results matching "<span class='search-query'></span>"
                                </h1>
                                <ul class="search-results-list"></ul>
                            </div>
                            <div class="no-results">
                                <h1 class="search-results-title">
                                    No results matching "<span class='search-query'></span>"
                                </h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <a href="arraybuffer.html" class="navigation navigation-prev"
           aria-label="Previous page: 29. ArrayBuffer">
            <i class="fa fa-angle-left"></i>
        </a>
        <a href="reference.html" class="navigation navigation-next"
           aria-label="Next page: 31. 参考链接">
            <i class="fa fa-angle-right"></i>
        </a>
    </div>

    <div class="back-to-top" style="display: block;"><i class="fa fa-arrow-up"></i></div>
    <script>
        var gitbook = gitbook || [];
        gitbook.push(function () {
            gitbook.page.hasChanged({
                "page": {
                    "title": "Changes",
                    "level": "2.1",
                    "depth": 1,
                    "next": {
                        "title": "31. 参考链接",
                        "level": "2.2",
                        "depth": 1,
                        "path": "next.md",
                        "ref": "next.md",
                        "articles": []
                    },
                    "previous": {
                        "title": "29. ArrayBuffer",
                        "level": "1.1",
                        "depth": 1,
                        "path": "prev.md",
                        "ref": "prev.md",
                        "articles": []
                    },
                    "dir": "ltr"
                },
                "config": {
                    "gitbook": "*",
                    "theme": "default",
                    "variables": {},
                    "plugins": [],
                    "pluginsConfig": {
                        "highlight": {},
                        "search": {},
                        "lunr": {"maxIndexSize": 1000000, "ignoreSpecialCharacters": false},
                        "sharing": {
                            "facebook": true,
                            "twitter": true,
                            "google": false,
                            "weibo": false,
                            "instapaper": false,
                            "vk": false,
                            "all": ["facebook", "google", "twitter", "weibo", "instapaper"]
                        },
                        "fontsettings": {"theme": "white", "family": "sans", "size": 2},
                        "theme-default": {
                            "styles": {
                                "website": "styles/website.css",
                                "pdf": "styles/pdf.css",
                                "epub": "styles/epub.css",
                                "mobi": "styles/mobi.css",
                                "ebook": "styles/ebook.css",
                                "print": "styles/print.css"
                            }, "showLevel": false
                        }
                    },
                    "structure": {
                        "langs": "LANGS.md",
                        "readme": "README.md",
                        "glossary": "GLOSSARY.md",
                        "summary": "SUMMARY.md"
                    },
                    "pdf": {
                        "pageNumbers": true,
                        "fontSize": 12,
                        "fontFamily": "Arial",
                        "paperSize": "a4",
                        "chapterMark": "pagebreak",
                        "pageBreaksBefore": "/",
                        "margin": {"right": 62, "left": 62, "top": 56, "bottom": 56}
                    },
                    "styles": {
                        "website": "styles/website.css",
                        "pdf": "styles/pdf.css",
                        "epub": "styles/epub.css",
                        "mobi": "styles/mobi.css",
                        "ebook": "styles/ebook.css",
                        "print": "styles/print.css"
                    }
                },
                "file": {"path": "content.md", "mtime": "2018-03-02T08:30:36.677Z", "type": "markdown"},
                "gitbook": {"version": "3.2.3", "time": "2018-03-02T08:32:31.453Z"},
                "basePath": ".",
                "book": {"language": ""}
            });
        });
    </script>
</div>
<script src="https://cdn.jim.plus/gitbook/gitbook.js"></script>
<script src="https://cdn.jim.plus/gitbook/theme.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
<!--
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search/search.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
-->
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-sharing/buttons.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
<script src="https://cdn.jim.plus/gitbook/gitbook-plugin-splitter/splitter.js"></script>
</body>
</html>